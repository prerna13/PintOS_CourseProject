diff -Naur ./os-pintos_clean/pintos/src/devices/shutdown.c ./os-pintos-a3/pintos/src/devices/shutdown.c
--- ./os-pintos_clean/pintos/src/devices/shutdown.c	2012-09-27 06:08:29.000000000 +0530
+++ ./os-pintos-a3/pintos/src/devices/shutdown.c	2018-03-24 17:39:01.004010562 +0530
@@ -98,7 +98,7 @@
 
   printf ("Powering off...\n");
   serial_flush ();
-
+  outw(0xB004,0x2000);
   /* This is a special power-off sequence supported by Bochs and
      QEMU, but not by physical hardware. */
   for (p = s; *p != '\0'; p++)
diff -Naur ./os-pintos_clean/pintos/src/Makefile.build ./os-pintos-a3/pintos/src/Makefile.build
--- ./os-pintos_clean/pintos/src/Makefile.build	2012-09-27 06:08:29.000000000 +0530
+++ ./os-pintos-a3/pintos/src/Makefile.build	2018-04-01 01:09:46.968029100 +0530
@@ -62,8 +62,8 @@
 userprog_SRC += userprog/tss.c		# TSS management.
 
 # No virtual memory code yet.
-#vm_SRC = vm/file.c			# Some file.
-
+vm_SRC  = vm/frame.c			# Frame Tables
+vm_SRC += vm/suppli.c
 # Filesystem code.
 filesys_SRC  = filesys/filesys.c	# Filesystem core.
 filesys_SRC += filesys/free-map.c	# Free sector bitmap.
diff -Naur ./os-pintos_clean/pintos/src/threads/palloc.c ./os-pintos-a3/pintos/src/threads/palloc.c
--- ./os-pintos_clean/pintos/src/threads/palloc.c	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/threads/palloc.c	2018-04-02 19:39:21.856022950 +0530
@@ -10,7 +10,7 @@
 #include "threads/loader.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
-
+#include "vm/frame.h"
 /* Page allocator.  Hands out memory in page-size (or
    page-multiple) chunks.  See malloc.h for an allocator that
    hands out smaller chunks.
@@ -34,7 +34,7 @@
   };
 
 /* Two pools: one for kernel data, one for user pages. */
-static struct pool kernel_pool, user_pool;
+static struct pool kernel_pool;
 
 static void init_pool (struct pool *, void *base, size_t page_cnt,
                        const char *name);
@@ -54,11 +54,11 @@
   if (user_pages > user_page_limit)
     user_pages = user_page_limit;
   kernel_pages = free_pages - user_pages;
-
+  
   /* Give half of memory to kernel, half to user. */
   init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
-  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
-             user_pages, "user pool");
+  init_frame_table(user_pages, free_start + kernel_pages * PGSIZE);
+
 }
 
 /* Obtains and returns a group of PAGE_CNT contiguous free pages.
@@ -70,7 +70,7 @@
 void *
 palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
 {
-  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
+  struct pool *pool = &kernel_pool;
   void *pages;
   size_t page_idx;
 
@@ -126,10 +126,10 @@
 
   if (page_from_pool (&kernel_pool, pages))
     pool = &kernel_pool;
-  else if (page_from_pool (&user_pool, pages))
-    pool = &user_pool;
   else
+  {
     NOT_REACHED ();
+  }
 
   page_idx = pg_no (pages) - pg_no (pool->base);
 
diff -Naur ./os-pintos_clean/pintos/src/threads/pte.h ./os-pintos-a3/pintos/src/threads/pte.h
--- ./os-pintos_clean/pintos/src/threads/pte.h	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/threads/pte.h	2018-03-31 19:12:22.684055291 +0530
@@ -66,7 +66,9 @@
 #define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
 #define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
 #define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */
-
+#define PTE_L (0x1<<9)          /* 1=lazy load, 0=no lazy load*/
+#define PTE_E (0x1<<10)         /* 1= Executable is lazy, 0=MMap is lazy*/
+#define PTE_S (0x1<<11)         /* 1= swapped out*/
 /* Returns a PDE that points to page table PT. */
 static inline uint32_t pde_create (uint32_t *pt) {
   ASSERT (pg_ofs (pt) == 0);
@@ -103,5 +105,8 @@
   return ptov (pte & PTE_ADDR);
 }
 
+static inline uint32_t pte_create_user_lazy( bool is_executable) {
+  return 0x0 | PTE_L | (is_executable ? PTE_E:0);
+}
 #endif /* threads/pte.h */
 
diff -Naur ./os-pintos_clean/pintos/src/threads/thread.c ./os-pintos-a3/pintos/src/threads/thread.c
--- ./os-pintos_clean/pintos/src/threads/thread.c	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/threads/thread.c	2018-04-02 03:43:04.512152078 +0530
@@ -11,6 +11,7 @@
 #include "threads/switch.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
+#include "threads/malloc.h"
 #ifdef USERPROG
 #include "userprog/process.h"
 #endif
@@ -184,6 +185,18 @@
   init_thread (t, name, priority);
   tid = t->tid = allocate_tid ();
 
+#ifdef USERPROG
+  if(tid != TID_ERROR)// && thread_current() != initial_thread) 
+  {
+    struct child *c = malloc(sizeof(struct child));
+    c->tid = tid;
+    c->status = -2;
+    c->child_thread = t;
+    //printf("list length %d, calling thread %s\n", list_size(&(thread_current()->child_proc)),name);
+    list_push_front(&(thread_current()->child_proc), &(c->elem));
+ //   printf("Heres the eror\n");
+  }
+#endif
   /* Prepare thread for first run by initializing its stack.
      Do this atomically so intermediate values for the 'stack' 
      member cannot be observed. */
@@ -290,9 +303,6 @@
 {
   ASSERT (!intr_context ());
 
-#ifdef USERPROG
-  process_exit ();
-#endif
 
   /* Remove thread from all threads list, set our status to dying,
      and schedule another process.  That process will destroy us
@@ -470,6 +480,24 @@
   t->priority = priority;
   t->magic = THREAD_MAGIC;
   list_push_back (&all_list, &t->allelem);
+#ifdef USERPROG
+  if(t != initial_thread)
+  {
+    t->parent = thread_current();
+  }
+  list_init(&(t->open_files));
+  t->curr_fd = 1;
+  t->is_parent_alive = 1;
+  cond_init(&(t->exec_cond));
+  lock_init(&(t->exec_lock));
+  t->exec_complete = -2;
+  list_init(&(t->child_proc));
+  t->executable_file = NULL;
+  list_init(&(t->lazy_pages));
+  t->curr_sp = 0x0;
+  t->mmap_id = 0;
+//  printf("child list initialized thread %s\n",name);
+#endif
 }
 
 /* Allocates a SIZE-byte frame at the top of thread T's stack and
diff -Naur ./os-pintos_clean/pintos/src/threads/thread.h ./os-pintos-a3/pintos/src/threads/thread.h
--- ./os-pintos_clean/pintos/src/threads/thread.h	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/threads/thread.h	2018-04-02 03:43:10.960152235 +0530
@@ -4,7 +4,8 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
-
+#include "threads/synch.h"
+#include "vm/suppli.h"
 /* States in a thread's life cycle. */
 enum thread_status
   {
@@ -24,6 +25,14 @@
 #define PRI_DEFAULT 31                  /* Default priority. */
 #define PRI_MAX 63                      /* Highest priority. */
 
+struct child
+{
+  tid_t tid;
+  int status;
+  struct thread *child_thread;
+  struct list_elem elem;
+};
+
 /* A kernel thread or user process.
 
    Each thread structure is stored in its own 4 kB page.  The
@@ -96,6 +105,23 @@
 #ifdef USERPROG
     /* Owned by userprog/process.c. */
     uint32_t *pagedir;                  /* Page directory. */
+
+    struct list open_files;
+    int curr_fd;                        /*To allocate file descriptors*/
+
+    struct condition exec_cond;
+    struct lock exec_lock;
+    int exec_complete;              /*To tell the parent thread of executable load completion. */
+
+    struct file* executable_file;   /* To disallow writes on executable of the current process*/
+    bool is_parent_alive;           /* Wait system call */
+    struct thread* parent;
+    struct list child_proc;
+
+    uint32_t *curr_sp;
+    int mmap_id;
+
+    struct list lazy_pages;
 #endif
 
     /* Owned by thread.c. */
diff -Naur ./os-pintos_clean/pintos/src/userprog/exception.c ./os-pintos-a3/pintos/src/userprog/exception.c
--- ./os-pintos_clean/pintos/src/userprog/exception.c	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/exception.c	2018-04-02 19:38:40.612021944 +0530
@@ -1,10 +1,14 @@
 #include "userprog/exception.h"
+#include "userprog/syscall.h"
 #include <inttypes.h>
 #include <stdio.h>
 #include "userprog/gdt.h"
 #include "threads/interrupt.h"
 #include "threads/thread.h"
-
+#include "threads/pte.h"
+#include "vm/suppli.h"
+#include "userprog/pagedir.h"
+//#include "threads/vaddr.h"
 /* Number of page faults processed. */
 static long long page_fault_cnt;
 
@@ -86,11 +90,11 @@
     case SEL_UCSEG:
       /* User's code segment, so it's a user exception, as we
          expected.  Kill the user process.  */
-      printf ("%s: dying due to interrupt %#04x (%s).\n",
-              thread_name (), f->vec_no, intr_name (f->vec_no));
-      intr_dump_frame (f);
-      thread_exit (); 
-
+    //  printf ("%s: dying due to interrupt %#04x (%s).\n",
+     //         thread_name (), f->vec_no, intr_name (f->vec_no));
+    //  intr_dump_frame (f);
+    //  thread_exit (); 
+        endprocess(-1);
     case SEL_KCSEG:
       /* Kernel's code segment, which indicates a kernel bug.
          Kernel code shouldn't throw exceptions.  (Page faults
@@ -148,14 +152,55 @@
   write = (f->error_code & PF_W) != 0;
   user = (f->error_code & PF_U) != 0;
 
+  if(is_user_vaddr(fault_addr))
+  {
+    uint32_t pte, *pte_addr;
+    pte_addr = lookup_page(thread_current()->pagedir, fault_addr, false);
+    if(not_present && pte_addr != NULL)
+    {
+      pte = *pte_addr;
+      if( (pte & PTE_L) != 0)
+      {
+        if((pte & PTE_E) != 0)
+        {
+          read_lazy_page(fault_addr, 1);
+        }
+        else
+        {
+          read_lazy_page(fault_addr, 0);
+        }
+
+      }
+      else if((pte & PTE_S) != 0)
+      {
+        //SWAPPED OUT COde
+      }
+      else if(pte == 0)
+      {
+        is_valid_stack(fault_addr,f->esp);
+      }
+      return;
+    }
+    else
+    {
+      endprocess(-1);
+    }
+  }
+  else if(!user)
+  {
   /* To implement virtual memory, delete the rest of the function
      body, and replace it with code that brings in the page to
      which fault_addr refers. */
-  printf ("Page fault at %p: %s error %s page in %s context.\n",
+    printf ("Page fault at %p: %s error %s page in %s context.\n",
           fault_addr,
           not_present ? "not present" : "rights violation",
           write ? "writing" : "reading",
           user ? "user" : "kernel");
-  kill (f);
+    kill (f);
+  }
+  else
+  {
+    endprocess(-1);
+  }
 }
 
diff -Naur ./os-pintos_clean/pintos/src/userprog/pagedir.c ./os-pintos-a3/pintos/src/userprog/pagedir.c
--- ./os-pintos_clean/pintos/src/userprog/pagedir.c	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/pagedir.c	2018-04-02 06:57:29.812436629 +0530
@@ -5,7 +5,8 @@
 #include "threads/init.h"
 #include "threads/pte.h"
 #include "threads/palloc.h"
-
+#include "threads/thread.h"
+#include "vm/frame.h"
 static uint32_t *active_pd (void);
 static void invalidate_pagedir (uint32_t *);
 
@@ -31,7 +32,7 @@
 
   if (pd == NULL)
     return;
-
+//	printf("pagedir_dest():thread:%s\n",thread_current()->name);
   ASSERT (pd != init_page_dir);
   for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
     if (*pde & PTE_P) 
@@ -41,7 +42,13 @@
         
         for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
           if (*pte & PTE_P) 
-            palloc_free_page (pte_get_page (*pte));
+          {
+          	// uint32_t upage = ( ((uint32_t)pde-(uint32_t)pd)>>2 )<<22;
+          	// upage += ( ((uint32_t)pte-(uint32_t)pt)>>2 )<<12;
+          	// printf("freeing page:%p, upage:%p, pde:%p pd:%p, pte:%p, pt:%p\n",pte_get_page(*pte), upage,( ((uint32_t)pte-(uint32_t)pt)>>2 )<<12,pd,pte,pt);
+            //palloc_free_page (pte_get_page (*pte));
+            deallocate_u_page(pte_get_page (*pte),false);
+          }
         palloc_free_page (pt);
       }
   palloc_free_page (pd);
@@ -53,7 +60,7 @@
    on CREATE.  If CREATE is true, then a new page table is
    created and a pointer into it is returned.  Otherwise, a null
    pointer is returned. */
-static uint32_t *
+uint32_t *
 lookup_page (uint32_t *pd, const void *vaddr, bool create)
 {
   uint32_t *pt, *pde;
@@ -109,11 +116,11 @@
   pte = lookup_page (pd, upage, true);
 
   if (pte != NULL) 
-    {
-      ASSERT ((*pte & PTE_P) == 0);
-      *pte = pte_create_user (kpage, writable);
-      return true;
-    }
+  {
+    ASSERT ((*pte & PTE_P) == 0);
+    *pte = (*pte) | pte_create_user (kpage, writable);
+    return true;
+  }
   else
     return false;
 }
@@ -243,7 +250,7 @@
   return ptov (pd);
 }
 
-/* Seom page table changes can cause the CPU's translation
+/* Some page table changes can cause the CPU's translation
    lookaside buffer (TLB) to become out-of-sync with the page
    table.  When this happens, we have to "invalidate" the TLB by
    re-activating it.
diff -Naur ./os-pintos_clean/pintos/src/userprog/pagedir.h ./os-pintos-a3/pintos/src/userprog/pagedir.h
--- ./os-pintos_clean/pintos/src/userprog/pagedir.h	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/pagedir.h	2018-03-30 01:19:18.292283210 +0530
@@ -14,5 +14,6 @@
 bool pagedir_is_accessed (uint32_t *pd, const void *upage);
 void pagedir_set_accessed (uint32_t *pd, const void *upage, bool accessed);
 void pagedir_activate (uint32_t *pd);
+uint32_t *lookup_page (uint32_t *pd, const void *vaddr, bool create);
 
 #endif /* userprog/pagedir.h */
diff -Naur ./os-pintos_clean/pintos/src/userprog/process.c ./os-pintos-a3/pintos/src/userprog/process.c
--- ./os-pintos_clean/pintos/src/userprog/process.c	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/process.c	2018-04-02 19:45:07.776031388 +0530
@@ -8,6 +8,7 @@
 #include "userprog/gdt.h"
 #include "userprog/pagedir.h"
 #include "userprog/tss.h"
+#include "userprog/syscall.h"
 #include "filesys/directory.h"
 #include "filesys/file.h"
 #include "filesys/filesys.h"
@@ -17,6 +18,9 @@
 #include "threads/palloc.h"
 #include "threads/thread.h"
 #include "threads/vaddr.h"
+#include "threads/malloc.h"
+#include "vm/suppli.h"
+#include "vm/frame.h"
 
 static thread_func start_process NO_RETURN;
 static bool load (const char *cmdline, void (**eip) (void), void **esp);
@@ -30,14 +34,13 @@
 {
   char *fn_copy;
   tid_t tid;
-
   /* Make a copy of FILE_NAME.
      Otherwise there's a race between the caller and load(). */
   fn_copy = palloc_get_page (0);
   if (fn_copy == NULL)
     return TID_ERROR;
   strlcpy (fn_copy, file_name, PGSIZE);
-
+//  printf("process_exec (): %s file is opening\n", file_name);
   /* Create a new thread to execute FILE_NAME. */
   tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
   if (tid == TID_ERROR)
@@ -53,18 +56,79 @@
   char *file_name = file_name_;
   struct intr_frame if_;
   bool success;
-
   /* Initialize interrupt frame and load executable. */
   memset (&if_, 0, sizeof if_);
   if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
   if_.cs = SEL_UCSEG;
   if_.eflags = FLAG_IF | FLAG_MBS;
+//get only the name of file from given file_name
+ char *token, *save_ptr;
+ token = strtok_r (file_name, " \n", &save_ptr);
+
+ 	lock_acquire(&(filesys_lock));
   success = load (file_name, &if_.eip, &if_.esp);
+  lock_release(&(filesys_lock));
+
+/* Function args code start */
+//get all words the from the file_name
+  int num_args = 0;
+
+  char *next_word = (char*)if_.esp - strnlen(token, PGSIZE) -1;
+  char **vec_args = (char*)if_.esp - PGSIZE;
+
+  success = success && (next_word >=  vec_args + num_args+1 + 3);
+  while(success)
+  {
+  	strlcpy(next_word, token, strnlen(token, PGSIZE)+1);
+  	vec_args[num_args] = next_word;
+  	num_args++;
+  	token = strtok_r (NULL, " \n", &save_ptr);
+  	
+  	if(token == NULL)
+  		break;
+  	else
+  		next_word -= (strnlen(token, PGSIZE) +1);
+  	
+  	success = next_word >= vec_args + num_args+1 + 4; //check for next_word writing over vec_args, 3 for argv, argc, ret_addr
+  }
+
+  /* If load failed, quit after notifing parent. */
+  if(!success)
+  {
+  	palloc_free_page (file_name);
+  	process_exit(-1);
+  	struct thread *cur = thread_current();
+  	lock_acquire(&(cur->parent->exec_lock));
+  	cur->parent->exec_complete = -1;
+  	cond_signal(&(cur->parent->exec_cond),&(cur->parent->exec_lock));
+  	lock_release(&(cur->parent->exec_lock));
+  	thread_exit ();
+  }
+  
+  while(((unsigned int)next_word)%4 != 0) // align with 4B
+  {
+  	*(--next_word) = 0;
+  }
+  next_word = ((char**)next_word) - 1;
+  *(next_word) = NULL;
+  next_word = (char**)next_word - num_args;
+  memmove( next_word, vec_args, sizeof(char*)*num_args);
+  *((char**)next_word-1) = next_word;
+  *((char**)next_word-2) = num_args; //as int is of same size as a char pointer
+  *((char**)next_word-3) = NULL;
+  if_.esp = (char**)next_word-3;
+ 	
+ 	struct thread *cur = thread_current();
+  cur->executable_file = filesys_open (file_name);
+  file_deny_write(cur->executable_file);
+
 
-  /* If load failed, quit. */
   palloc_free_page (file_name);
-  if (!success) 
-    thread_exit ();
+  
+  lock_acquire(&(cur->parent->exec_lock));
+  cur->parent->exec_complete = 0;
+  cond_signal(&(cur->parent->exec_cond),&(cur->parent->exec_lock));
+  lock_release(&(cur->parent->exec_lock));  
 
   /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
@@ -86,16 +150,62 @@
    This function will be implemented in problem 2-2.  For now, it
    does nothing. */
 int
-process_wait (tid_t child_tid UNUSED) 
+process_wait (tid_t child_tid )//UNUSED) //ono-to-one mapping between tid and pid
 {
-  return -1;
+
+	struct list_elem *e;
+	struct thread *t = thread_current();
+	struct child *c = NULL;
+  for (e = list_begin (&(t->child_proc)); e != list_end (&(t->child_proc)); e = list_next (e))
+  {
+    
+    if(list_entry (e, struct child, elem)->tid == child_tid)
+    	c = list_entry (e, struct child, elem);
+  }
+  if(c == NULL)
+  {
+  	return -1;
+  }
+  while(c->status == -2)
+  {
+  	thread_yield();
+  }
+  int status = c->status;
+  list_remove(&(c->elem));
+  free(c);
+   return status;
 }
 
 /* Free the current process's resources. */
 void
-process_exit (void)
+process_exit (int status)
 {
   struct thread *cur = thread_current ();
+	struct list_elem *e;
+	for (e = list_begin (&(cur->child_proc)); e != list_end (&(cur->child_proc));)
+  {
+    struct child *c = list_entry (e, struct child, elem);
+    c->child_thread->is_parent_alive = 0;
+    e = list_next (e);
+    free(c);
+  }
+
+	if(cur->is_parent_alive)
+	{
+		struct list *siblings = &(cur->parent->child_proc);
+		for(e = list_begin(siblings); e != list_end(siblings); e = list_next(e))
+		{
+			struct child *c = list_entry(e, struct child, elem);
+			if(c->tid == cur->tid)
+				c->status = status;
+		}
+	}
+	if(cur->executable_file != NULL)
+	  {
+	  	file_allow_write (cur->executable_file);
+			file_close (cur->executable_file);
+		}
+
   uint32_t *pd;
 
   /* Destroy the current process's page directory and switch back
@@ -197,9 +307,6 @@
 
 static bool setup_stack (void **esp);
 static bool validate_segment (const struct Elf32_Phdr *, struct file *);
-static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
-                          uint32_t read_bytes, uint32_t zero_bytes,
-                          bool writable);
 
 /* Loads an ELF executable from FILE_NAME into the current thread.
    Stores the executable's entry point into *EIP
@@ -291,8 +398,8 @@
                   read_bytes = 0;
                   zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
                 }
-              if (!load_segment (file, file_page, (void *) mem_page,
-                                 read_bytes, zero_bytes, writable))
+              if (!map_segment (file_page, (void *) mem_page,
+                                 read_bytes, zero_bytes, writable, true))
                 goto done;
             }
           else
@@ -304,9 +411,10 @@
   /* Set up stack. */
   if (!setup_stack (esp))
     goto done;
-
+  t->curr_sp = *((uint32_t **)esp);
   /* Start address. */
   *eip = (void (*) (void)) ehdr.e_entry;
+  // printf("PC is %p\n", *eip);
 
   success = true;
 
@@ -379,15 +487,17 @@
 
    Return true if successful, false if a memory allocation error
    or disk read error occurs. */
-static bool
-load_segment (struct file *file, off_t ofs, uint8_t *upage,
-              uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
+bool
+map_segment (off_t ofs, uint8_t *upage,
+              uint32_t read_bytes, uint32_t zero_bytes, bool writable, bool is_executable) 
 {
+  // printf("load_seg(): upage %p, writable %d, read_bytes %d, zero_bytes: %d\n", upage, writable, read_bytes,zero_bytes);
+
   ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
   ASSERT (pg_ofs (upage) == 0);
   ASSERT (ofs % PGSIZE == 0);
 
-  file_seek (file, ofs);
+  int i =0;
   while (read_bytes > 0 || zero_bytes > 0) 
     {
       /* Calculate how to fill this page.
@@ -396,27 +506,10 @@
       size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
       size_t page_zero_bytes = PGSIZE - page_read_bytes;
 
-      /* Get a page of memory. */
-      uint8_t *kpage = palloc_get_page (PAL_USER);
-      if (kpage == NULL)
-        return false;
-
-      /* Load this page. */
-      if (file_read (file, kpage, page_read_bytes) != (int) page_read_bytes)
-        {
-          palloc_free_page (kpage);
-          return false; 
-        }
-      memset (kpage + page_read_bytes, 0, page_zero_bytes);
-
-      /* Add the page to the process's address space. */
-      if (!install_page (upage, kpage, writable)) 
-        {
-          palloc_free_page (kpage);
-          return false; 
-        }
 
+      lazy_read(upage, page_read_bytes, page_zero_bytes, ofs + PGSIZE*i, writable, is_executable);
       /* Advance. */
+      i++;
       read_bytes -= page_read_bytes;
       zero_bytes -= page_zero_bytes;
       upage += PGSIZE;
@@ -429,37 +522,13 @@
 static bool
 setup_stack (void **esp) 
 {
-  uint8_t *kpage;
+
   bool success = false;
+  uint8_t *upage = ((uint8_t *) PHYS_BASE) - PGSIZE;
+  success = !allocate_u_page( upage, 1);
+  memset (upage , 0, PGSIZE);
+  *esp = PHYS_BASE;
 
-  kpage = palloc_get_page (PAL_USER | PAL_ZERO);
-  if (kpage != NULL) 
-    {
-      success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
-      if (success)
-        *esp = PHYS_BASE;
-      else
-        palloc_free_page (kpage);
-    }
   return success;
 }
 
-/* Adds a mapping from user virtual address UPAGE to kernel
-   virtual address KPAGE to the page table.
-   If WRITABLE is true, the user process may modify the page;
-   otherwise, it is read-only.
-   UPAGE must not already be mapped.
-   KPAGE should probably be a page obtained from the user pool
-   with palloc_get_page().
-   Returns true on success, false if UPAGE is already mapped or
-   if memory allocation fails. */
-static bool
-install_page (void *upage, void *kpage, bool writable)
-{
-  struct thread *t = thread_current ();
-
-  /* Verify that there's not already a page at that virtual
-     address, then map our page there. */
-  return (pagedir_get_page (t->pagedir, upage) == NULL
-          && pagedir_set_page (t->pagedir, upage, kpage, writable));
-}
diff -Naur ./os-pintos_clean/pintos/src/userprog/process.h ./os-pintos-a3/pintos/src/userprog/process.h
--- ./os-pintos_clean/pintos/src/userprog/process.h	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/process.h	2018-04-02 04:54:35.736256754 +0530
@@ -2,10 +2,11 @@
 #define USERPROG_PROCESS_H
 
 #include "threads/thread.h"
-
+#include "filesys/file.h"
 tid_t process_execute (const char *file_name);
 int process_wait (tid_t);
-void process_exit (void);
+void process_exit (int status);
 void process_activate (void);
-
+bool map_segment (off_t ofs, uint8_t *upage, uint32_t read_bytes, uint32_t zero_bytes,
+                          bool writable, bool is_executable);
 #endif /* userprog/process.h */
diff -Naur ./os-pintos_clean/pintos/src/userprog/syscall.c ./os-pintos-a3/pintos/src/userprog/syscall.c
--- ./os-pintos_clean/pintos/src/userprog/syscall.c	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/syscall.c	2018-04-02 19:46:52.956033954 +0530
@@ -3,18 +3,424 @@
 #include <syscall-nr.h>
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "threads/synch.h"
+#include "devices/input.h"
+#include "devices/shutdown.h"
+#include "filesys/filesys.h"
+#include "filesys/file.h"
+#include "threads/malloc.h"
+#include "threads/vaddr.h"
+#include "userprog/pagedir.h"
+#include "userprog/process.h"
+#include "threads/pte.h"
+#include <list.h>
+#include <string.h>
+#include <round.h>
 
+#define MIN_USER_VADDR ((void*)0x08084000)
+
+#define READ_U_ADDRESS(PTR, TYPE) (*((TYPE *) check_address((void *)(PTR)) ) )
 static void syscall_handler (struct intr_frame *);
+static void munmap(int mmap_id);
+
+struct lock filesys_lock;
+
+static inline void* check_address(void* user_vaddr){
+	if( !is_user_vaddr(user_vaddr) )
+		endprocess(-1);
+	return(user_vaddr);
+}
 
+static int check_buffer(char *buf, int max_len, char *delim);
+static int add_file(struct file* f_ptr);
+static struct file * remove_file(int fd);
+static int exec_file(char* filename);
+static int mmap(int fd, void *upage);
 void
 syscall_init (void) 
 {
-  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
+	lock_init(&filesys_lock);
+	intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
 }
 
+struct file_desc
+{
+	struct file* file_ptr;
+	int fd;
+	struct list_elem elem;
+};
+
 static void
-syscall_handler (struct intr_frame *f UNUSED) 
+syscall_handler (struct intr_frame *f )//UNUSED) 
+{
+	uint32_t* u_esp = f->esp;
+	int call_num = READ_U_ADDRESS(u_esp, int);
+	call_num = *u_esp;
+	thread_current()->curr_sp = f->esp;
+	struct file *f_ptr = NULL;
+	char *f_name = NULL;
+	int fd = -1;
+	char* buffer= NULL;
+	int buff_size = 0;
+	int i = -1;
+	int seek_pos = 0;
+	int ret = 0;
+	int status = -1;
+	int tid = 0;
+//	printf("syscall_handler clled with call=%d\n",call_num);
+	switch(call_num)
+	{
+	case SYS_HALT:		/* Halt the operating system. */
+		shutdown_power_off();
+		NOT_REACHED();
+		break;
+
+	case SYS_EXIT:		/* Terminate this process. */
+		status = READ_U_ADDRESS(u_esp+1, int);
+		endprocess(status);
+
+		break;
+
+	case SYS_EXEC:		/* Start another process. */
+		f_name = READ_U_ADDRESS(u_esp+1, char*);
+		check_buffer(f_name, 14, "\0");
+		f->eax = exec_file( f_name);
+		
+		break;
+
+	case SYS_WAIT:		/* Wait for tid process to die. */
+		tid = READ_U_ADDRESS(u_esp+1, int);
+		f->eax = process_wait(tid);
+		break;
+
+	case SYS_CREATE:		/* Create a file. */
+		f_name = READ_U_ADDRESS((void*)(u_esp+4), char*);
+		int init_size = READ_U_ADDRESS(u_esp+5, int);
+		check_buffer(f_name, 14, "\0");
+		lock_acquire(&filesys_lock);
+		f->eax = filesys_create(f_name, init_size);
+		lock_release(&filesys_lock);
+
+		break;
+
+	case SYS_REMOVE:		/* Delete a file. */
+		f_name = READ_U_ADDRESS(u_esp+1, char*);
+		check_buffer(f_name, 14, "\0");
+		lock_acquire(&filesys_lock);
+		f->eax = filesys_remove(f_name);//succes is return value
+		lock_release(&filesys_lock);
+		break;
+
+	case SYS_OPEN:		/* Open a file. */
+		f_name = READ_U_ADDRESS(u_esp+1, char*);
+		check_buffer(f_name, 14, "\0");
+		f->eax =	-1;	
+		lock_acquire(&filesys_lock);
+		f_ptr = filesys_open(f_name);
+		lock_release(&filesys_lock);
+		f->eax = add_file(f_ptr);
+		break;
+
+	case SYS_FILESIZE:		/* Obtain a file's size. */
+		fd = READ_U_ADDRESS(u_esp+1, int);
+		f_ptr = get_file(fd);
+		ret = -1;
+		if(f_ptr != NULL)
+		{
+			lock_acquire(&filesys_lock);
+			ret = file_length(f_ptr);
+			lock_release(&filesys_lock);
+		}
+		f->eax =	ret;
+		break;
+
+	case SYS_READ:			/* Read from a file. */
+		fd = READ_U_ADDRESS(u_esp+5, int);
+		buffer = READ_U_ADDRESS(u_esp+6, char*);
+		buff_size = READ_U_ADDRESS(u_esp+7, int);
+		check_buffer(buffer, buff_size, NULL);
+		int bytes_read = -1;
+		if(fd>1)
+		{
+			f_ptr = get_file(fd);
+			if(f_ptr != NULL)
+			{
+				lock_acquire(&filesys_lock);
+				bytes_read = file_read (f_ptr, buffer, buff_size);
+				lock_release(&filesys_lock);
+			}
+		}
+		else if(fd == 0)
+		{
+			for(i = 0; i<buff_size; i++)
+			{
+				buffer[i] = input_getc();
+			}
+			bytes_read = buff_size;
+		}
+		f->eax =	bytes_read;
+		break;
+
+	case SYS_WRITE:			/* Write to a file. */
+		fd = READ_U_ADDRESS(u_esp+5, int);
+		buffer = READ_U_ADDRESS(u_esp+6, char*);
+		buff_size = READ_U_ADDRESS(u_esp+7, int);
+		check_buffer(buffer, buff_size, NULL);
+
+		int bytes_writn=-1;
+		if(fd>1)
+		{
+			f_ptr = get_file(fd);
+			if(f_ptr != NULL)
+			{
+				lock_acquire(&filesys_lock);
+				bytes_writn = file_write (f_ptr, buffer, buff_size);
+				lock_release(&filesys_lock);
+			}
+		}
+		else if(fd == 1)
+		{
+			putbuf(buffer, buff_size);
+			bytes_writn = buff_size;
+		}
+
+		f->eax =	bytes_writn;
+		break;
+
+	case SYS_SEEK:		/* Change position in a file. */
+		fd = READ_U_ADDRESS(u_esp+4, int);
+		seek_pos = READ_U_ADDRESS(u_esp+5, int);
+		f_ptr = get_file(fd);
+		if(f_ptr != NULL)
+		{
+			lock_acquire(&filesys_lock);
+			file_seek (f_ptr, seek_pos);
+			lock_release(&filesys_lock);
+		}
+
+		break;
+
+	case SYS_TELL:			/* Report current position in a file. */
+		fd = READ_U_ADDRESS(u_esp+1, int);
+		f_ptr = get_file(fd);
+		ret = -1;
+		if(f_ptr != NULL)
+		{
+			lock_acquire(&filesys_lock);
+			ret = file_tell (f_ptr);
+			lock_release(&filesys_lock);
+		}
+		f->eax =	ret;
+		break;
+
+	case SYS_CLOSE:			/* Close a file. */
+		fd = READ_U_ADDRESS(u_esp+1, int);
+		f_ptr = remove_file(fd);
+		if(f_ptr != NULL)
+		{
+			lock_acquire(&filesys_lock);
+			file_close(f_ptr);
+			lock_release(&filesys_lock);
+		}
+		break;
+	case SYS_MMAP:
+		fd = READ_U_ADDRESS(u_esp+4, int);
+		f->eax = mmap(fd, READ_U_ADDRESS(u_esp+5, int*));
+		break;
+	case SYS_MUNMAP:
+		munmap(READ_U_ADDRESS(u_esp+1, int));
+		break;
+	default:
+		printf ("Invalid system call!\n");
+		break;
+	}
+
+//	printf ("system call!\n");
+//	thread_exit ();
+}
+
+int check_buffer(char* buff, int max_len, char *delim)
+{
+	int i;
+	for (i=0; i<max_len; ++i)
+	{
+		check_address(buff + i);
+		if(delim != NULL && buff[i] == *delim)
+			break;
+	}
+	return i;
+}
+
+int mmap(int fd_orig, void *upage)
+{
+	if(pg_ofs(upage) != 0 || fd_orig <= 1 || !is_user_vaddr(upage) || upage <= MIN_USER_VADDR)
+		return -1;
+	struct file *f = get_file(fd_orig);
+	struct thread *t = thread_current();
+	int fd = -1;
+	if(f != NULL && file_length(f) > 0)
+	{
+		lock_acquire(&(filesys_lock));
+		struct file *file = file_reopen(f);
+		int read_bytes = file_length(file);
+		lock_release(&(filesys_lock));
+		fd = add_file(file);
+		if(fd >1)
+		{
+			int num_pages = DIV_ROUND_UP(read_bytes, PGSIZE);
+			int i;
+			for(i =0; i < num_pages; i++)
+			{
+				uint32_t *pte = lookup_page (t->pagedir, upage+ i*PGSIZE, false);	
+				if(pte != NULL && *pte != 0)
+					return -1;
+			}
+			t->mmap_id = fd;
+			int zero_bytes = num_pages*PGSIZE - read_bytes;
+			map_segment (0, upage, read_bytes, zero_bytes, true, false);
+			return fd;
+		}
+   	}
+   	return -1;
+}
+
+void munmap(int mmap_id)
+{
+	if(mmap_id <= 1)
+		return;
+	struct thread *t = thread_current();
+	uint32_t *pd = t->pagedir;
+	struct list_elem *e;
+	int fd = mmap_id;
+	struct file * f = get_file(fd);
+	for (e = list_begin (&(t->lazy_pages)); e != list_end (&(t->lazy_pages));)
+  	{
+    	struct lazy_page *l = list_entry (e, struct lazy_page, elem);
+    	struct list_elem *e_temp = e;
+    	e = list_next (e);
+    	if(l->mmap_id == mmap_id)
+    	{
+    		if(pagedir_is_dirty(pd, l->user_vaddr))
+			{
+				lock_acquire(&(filesys_lock));
+				file_seek(f, l->ofs);
+				file_write(f, l->user_vaddr, l->page_read_bytes);
+				lock_release(&(filesys_lock));
+			}
+    		list_remove(e_temp);
+    		free(l);
+    	}
+	}
+	remove_file(fd);
+}
+
+void endprocess(int status)		
+{
+	struct thread *cur = thread_current();
+	struct list_elem *e;
+	for (e = list_begin (&(cur->lazy_pages)); e != list_end (&(cur->lazy_pages));)
+  	{
+    	struct lazy_page *l = list_entry (e, struct lazy_page, elem);
+    	uint32_t *pte = lookup_page(cur->pagedir, l->user_vaddr, false);
+		if(pagedir_is_dirty(cur->pagedir, l->user_vaddr) && !(*pte & PTE_E))
+		{
+			if(!lock_held_by_current_thread (&filesys_lock))
+				lock_acquire(&filesys_lock);
+			file_seek(get_file(l->mmap_id), l->ofs);
+			file_write(get_file(l->mmap_id), l->user_vaddr, l->page_read_bytes);
+			lock_release(&(filesys_lock));
+		}
+		e = list_next (e);
+    	free(l);
+	}
+	for (e = list_begin (&(cur->open_files)); e != list_end (&(cur->open_files));)
+	{
+		struct file_desc *f = list_entry (e, struct file_desc, elem);
+		if(!lock_held_by_current_thread (&filesys_lock))
+			lock_acquire(&filesys_lock);
+		file_close(f->file_ptr);
+		lock_release(&filesys_lock);
+		e = list_next (e);
+		free(f);
+	}
+
+	char *token, *save_ptr;
+	token = strtok_r (cur->name, " \n", &save_ptr);
+	printf("%s: exit(%d)\n",token,status);
+	process_exit(status);
+	thread_exit();
+	NOT_REACHED();
+}
+
+int add_file(struct file* f_ptr)
+{
+	int fd = -1;
+	if(f_ptr != NULL)
+	{
+		struct thread *t = thread_current();
+		struct file_desc *p = malloc(sizeof(struct file_desc));
+		p->file_ptr = f_ptr;
+		fd = p->fd = ++(t->curr_fd);
+		list_push_back(&(t->open_files), &(p->elem));
+	}
+	return fd;
+}
+
+struct file * get_file(int fd)
+{
+	struct thread *t = thread_current();
+	struct file *f_ptr = NULL;
+	struct list_elem *e;
+	for (e = list_begin (&(t->open_files)); e != list_end (&(t->open_files)); e = list_next(e))
+	{
+		struct file_desc *f = list_entry(e, struct file_desc, elem);
+		if(fd == f->fd)
+		{
+			f_ptr = f->file_ptr;
+			break;
+		}
+	}
+	return f_ptr;
+}
+
+struct file * remove_file(int fd)
+{
+	struct thread *t = thread_current();
+	struct file *f_ptr = NULL;
+	struct list_elem *e;
+	for (e = list_begin (&(t->open_files)); e != list_end (&(t->open_files)); e = list_next(e))
+	{
+		struct file_desc *f = list_entry (e, struct file_desc, elem);
+		if(fd == f->fd)
+		{
+			f_ptr = f->file_ptr;
+			list_remove (e);
+			free(f);
+			break;
+		}
+	}
+	return f_ptr;
+}
+int exec_file(char* filename)
 {
-  printf ("system call!\n");
-  thread_exit ();
+	struct thread *cur = thread_current(); 
+	
+	lock_acquire(&(cur->exec_lock));
+	int pid = process_execute(filename);
+	while(cur->exec_complete == -2)		//-2 is invalid status.
+	{
+		cond_wait(&(cur->exec_cond),&(cur->exec_lock));
+	}
+	int status = cur->exec_complete;
+	cur->exec_complete = -2;
+	lock_release(&(cur->exec_lock));
+	if(status == -1)
+	{
+		return -1;
+	}
+	if(status == 0)
+	{
+		return pid;
+	}
+	return -1;
 }
diff -Naur ./os-pintos_clean/pintos/src/userprog/syscall.h ./os-pintos-a3/pintos/src/userprog/syscall.h
--- ./os-pintos_clean/pintos/src/userprog/syscall.h	2012-09-27 06:08:38.000000000 +0530
+++ ./os-pintos-a3/pintos/src/userprog/syscall.h	2018-04-02 05:11:01.176280792 +0530
@@ -1,6 +1,9 @@
 #ifndef USERPROG_SYSCALL_H
 #define USERPROG_SYSCALL_H
-
+#include <filesys/file.h>
 void syscall_init (void);
 
+extern struct lock filesys_lock;
+void endprocess(int status);
+struct file* get_file(int fd);
 #endif /* userprog/syscall.h */
diff -Naur ./os-pintos_clean/pintos/src/vm/frame.c ./os-pintos-a3/pintos/src/vm/frame.c
--- ./os-pintos_clean/pintos/src/vm/frame.c	1970-01-01 05:30:00.000000000 +0530
+++ ./os-pintos-a3/pintos/src/vm/frame.c	2018-04-02 19:42:42.456027844 +0530
@@ -0,0 +1,157 @@
+#include"vm/frame.h"
+#include"threads/synch.h"
+#include <stdint.h>
+#include <stdio.h>
+#include <round.h>
+#include "userprog/pagedir.h"
+#include "threads/thread.h"
+#include "threads/vaddr.h"
+#include "threads/pte.h"
+ 
+struct frame_pool
+{
+	uint8_t *base;
+	uint32_t **frame_table;
+	uint32_t page_count;
+	struct lock lock;
+};
+static struct frame_pool user_pool;//, kernel_pool;
+/*Initialize the frame_table to array of NUM_PAGES ints and 
+	base_paddr to the Kernel Virtual address for start of the 
+	TYPE pool passed as BASE_ADDRESS. 
+*/
+void init_frame_table(size_t num_pages, uint8_t *base_address)//, enum pool_type type )
+{
+	/* Store the frame table at base address of each pool.	*/
+	size_t bm_pages = DIV_ROUND_UP (num_pages*sizeof(uint32_t*), PGSIZE);	//this may waste one page max.
+  if (bm_pages > num_pages)
+    PANIC ("Not enough memory in %s for bitmap.", "user pool");
+  num_pages -= bm_pages;
+  struct frame_pool *p = &user_pool;
+  p->frame_table = (uint32_t**) base_address;
+  printf ("%zu pages available in %s.\n", num_pages, "user pool");
+
+  lock_init(&(p->lock));
+  uint32_t i;
+	for( i =0; i<num_pages; ++i)
+	{
+		p->frame_table[i] = NULL;
+	}
+	p->page_count = num_pages;
+	p->base = base_address + PGSIZE*bm_pages;
+	printf("init_frame_table(): base_address: %p, num_pages %d\n",p->base, num_pages);
+}
+
+/*
+	Allocates a frame and returns -1 if fail and 0 if success.
+*/
+int allocate_u_page( void* upage, uint8_t num_pages)//, enum pool_type type)
+{
+
+	struct frame_pool *p = &user_pool;
+	uint32_t *pd = thread_current()->pagedir;
+	if(pagedir_get_page (pd, upage)  != NULL)
+	{
+		printf("allocate_frame(): Trying to allocate memory at already allocated upage\n");
+		return -1;
+	}
+	if( num_pages >1)
+	{
+		printf("allocate_frame(): User space asking for %d number of pages!\n",num_pages);
+		return -1;
+	}
+
+	uint32_t pg_idx =0;
+	lock_acquire(&(p->lock));
+	for(; pg_idx < p->page_count; ++pg_idx)
+	{
+		if(p->frame_table[pg_idx] == NULL)
+			break;
+	}
+
+	/*eviction policy and swapping partition.
+	*/
+	if(pagedir_set_page (pd, upage, p->base + PGSIZE*pg_idx, true))
+	{
+		uint32_t *pte_address = lookup_page(pd, upage, false);
+		p->frame_table[pg_idx] = pte_address;
+		lock_release(&(p->lock));
+		return 0;
+	}
+	else
+	{
+		printf("allocate_frame(): Unable to allocate space for PT entry\n");
+		lock_release(&(p->lock));
+		return -1;
+	}
+	return -1;
+}
+
+int set_writable(void *upage, bool writable)
+{
+	ASSERT(pg_ofs(upage) == 0);
+  ASSERT (is_user_vaddr (upage));
+
+ 	struct frame_pool *p = &user_pool;
+	uint32_t *pd = thread_current()->pagedir;
+	uint32_t *kpage = pagedir_get_page (pd, upage);
+	
+	if(kpage  == NULL)
+	{
+		printf("set_writable(): Trying to change an unallocated upage\n");
+		return -1;
+	}
+	uint32_t page_idx = pg_no (kpage) - pg_no (p->base);
+	uint32_t *pte_address;
+	lock_acquire(&(p->lock));	
+	pte_address = p->frame_table[page_idx];
+	lock_release(&(p->lock));
+	
+	if(pte_address != NULL)
+	{
+		if(writable)
+			*pte_address = (*pte_address)|PTE_W;
+		else
+			*pte_address = (*pte_address)& (~PTE_W);
+		return 0;
+	}
+	else
+	{
+		PANIC("trying to set writable an unallocated user address");
+	}
+	return -1;
+}
+
+int deallocate_u_page(void* page, bool is_user_page)
+{
+	struct frame_pool *p = &user_pool;
+	uint32_t page_idx;
+	if(is_user_page)
+	{
+  	ASSERT (is_user_vaddr (page));
+		uint32_t *pd = thread_current()->pagedir;
+		uint32_t *kpage = pagedir_get_page (pd, page);
+		if(kpage  == NULL)
+		{
+			printf("deallocate_frame(): Trying to free memory at already unallocated upage\n");
+			return -1;
+		}
+		page_idx = pg_no (kpage) - pg_no (p->base);
+		pagedir_clear_page(pd, page);
+	}
+	else
+	{
+		is_kernel_vaddr (page);
+		page_idx = pg_no(page) - pg_no(p->base);
+	}
+
+	lock_acquire(&(p->lock));	
+	if(p->frame_table[page_idx] == NULL)
+	{
+		PANIC("User Frame free while allocated on page\n");
+	}
+	p->frame_table[page_idx] = NULL;
+	lock_release(&(p->lock));
+
+	return 0;
+}
diff -Naur ./os-pintos_clean/pintos/src/vm/frame.h ./os-pintos-a3/pintos/src/vm/frame.h
--- ./os-pintos_clean/pintos/src/vm/frame.h	1970-01-01 05:30:00.000000000 +0530
+++ ./os-pintos-a3/pintos/src/vm/frame.h	2018-03-31 04:38:08.168151851 +0530
@@ -0,0 +1,16 @@
+#ifndef VM_FRAME_H
+#define VM_FRAME_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+void init_frame_table(size_t num_pages, uint8_t *base_address);//, enum pool_type type );
+
+int allocate_u_page(void* upage, uint8_t num_pages);
+
+int set_writable(void *upage, bool writable);
+
+int deallocate_u_page(void* upage, bool is_user_page);
+
+#endif
\ No newline at end of file
diff -Naur ./os-pintos_clean/pintos/src/vm/suppli.c ./os-pintos-a3/pintos/src/vm/suppli.c
--- ./os-pintos_clean/pintos/src/vm/suppli.c	1970-01-01 05:30:00.000000000 +0530
+++ ./os-pintos-a3/pintos/src/vm/suppli.c	2018-04-02 19:39:45.120023518 +0530
@@ -0,0 +1,105 @@
+#include "vm/suppli.h"
+#include "threads/thread.h"
+#include "threads/synch.h"
+#include "userprog/syscall.h"
+#include "vm/frame.h"
+#include "userprog/pagedir.h"
+#include "threads/pte.h"
+#include "threads/malloc.h"
+#include "filesys/file.h"
+#include <string.h>
+
+#define MIN_STACK_PTR ((void *)0xbfeff000)	//1MB to stack
+void lazy_read(void* upage, uint32_t page_read_bytes, uint32_t page_zero_bytes, size_t ofs,
+							 bool writable, bool is_executable)
+{
+	struct thread *t = thread_current();
+	uint32_t *pd = t->pagedir;
+	
+	uint32_t *pte = lookup_page (pd, upage, true);	
+
+	if(pte != NULL)
+	{
+		*pte = pte_create_user_lazy(is_executable);
+	}
+	struct lazy_page *l = malloc(sizeof(struct lazy_page));
+	l->user_vaddr = upage;
+	l->page_read_bytes = page_read_bytes;
+	l->page_zero_bytes = page_zero_bytes;
+	l->ofs = ofs;
+	l->writable = writable;
+	l->mmap_id = is_executable?-1:t->mmap_id;
+	list_push_back (&(t->lazy_pages), &(l->elem));
+}
+
+void read_lazy_page(void* fault_addr, bool is_executable)
+{
+	struct thread *t = thread_current();
+	struct list_elem *e;
+	void *upage = (void*)((uint32_t)fault_addr & 0xFFFFF000u);
+  for (e = list_begin (&(t->lazy_pages)); e != list_end (&(t->lazy_pages)); e = list_next (e))
+  {
+    struct lazy_page *l = list_entry (e, struct lazy_page, elem);
+    if(l->user_vaddr == upage)
+    {
+    	if(allocate_u_page(upage, 1))
+    	{
+    		endprocess(-1);
+    		return;
+    	}
+    	if(l->page_read_bytes != 0)
+    	{
+	    	struct file *f;
+  		 	if(is_executable)
+   		 		f = t->executable_file;
+    		else
+    		f = get_file(l->mmap_id);
+    		if(!lock_held_by_current_thread (&filesys_lock))
+    			lock_acquire(&filesys_lock);
+    		file_seek(f, l->ofs);
+   		 	if(file_read (f, upage, l->page_read_bytes) != (int) l->page_read_bytes)
+      	{
+     		 	deallocate_u_page(upage, true);
+   		   	endprocess(-1);
+      		return;
+      	}
+      	lock_release(&filesys_lock);
+      }
+      if(l->page_zero_bytes != 0)
+	      memset (upage + l->page_read_bytes, 0, l->page_zero_bytes);
+      set_writable(upage, l->writable);
+      pagedir_set_dirty (t->pagedir, upage, 0) ;
+      return;
+    }
+  }
+  endprocess(-1);
+}
+void is_valid_stack(void *fault_vaddr, void* stack_ptr)
+{
+	void * upage = (void*)(pg_no(fault_vaddr)<<12);
+
+	if(is_user_vaddr(stack_ptr) && stack_ptr > MIN_STACK_PTR)
+	{
+		if(fault_vaddr >= stack_ptr || ((char *)fault_vaddr) +32 >= (char*)stack_ptr )
+		{
+			if(allocate_u_page(upage, 1))
+    	{
+    		endprocess(-1);
+    	}
+     	set_writable(upage, true);
+     	thread_current()->curr_sp = stack_ptr;
+     	return;
+		}
+		endprocess(-1);
+	}
+	else if(fault_vaddr >= (void*)(thread_current()->curr_sp))
+	{
+		if(allocate_u_page(upage, 1))
+    {
+    	endprocess(-1);
+    }
+    set_writable(upage, true);
+    return;
+	}
+	endprocess(-1);
+}
\ No newline at end of file
diff -Naur ./os-pintos_clean/pintos/src/vm/suppli.h ./os-pintos-a3/pintos/src/vm/suppli.h
--- ./os-pintos_clean/pintos/src/vm/suppli.h	1970-01-01 05:30:00.000000000 +0530
+++ ./os-pintos-a3/pintos/src/vm/suppli.h	2018-04-02 04:52:50.488254187 +0530
@@ -0,0 +1,24 @@
+#ifndef vm_supp_page_table
+#define vm_supp_page_table
+
+#include<list.h>
+#include<stdbool.h>
+#include<stdint.h>
+
+struct lazy_page
+{
+	void* user_vaddr;
+	uint32_t page_read_bytes;
+	uint32_t page_zero_bytes;
+	size_t ofs;
+	bool writable;
+	int mmap_id;
+	struct list_elem elem;
+};
+void lazy_read(void* upage, uint32_t page_read_bytes, uint32_t page_zero_bytes, size_t ofs,
+							 bool writable, bool is_executable);
+
+void read_lazy_page(void* upage, bool is_executable);
+void is_valid_stack(void *fault_vaddr, void* stack_ptr);
+
+#endif
\ No newline at end of file
